# 设计原则

## 资源

- [设计模式原则](https://zhuanlan.zhihu.com/p/457009285)

## 单一职责原则

- 定义：
  - 一个类只负责完成一个职责或者功能
  - 实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性
- 如何判断类的职责是否足够单一？
  - 同一个类是否符合单一职责在 不同状态下不一样
    - 不同的应用场景
    - 不同阶段的需求背景
    - 不同的业务层面
  - 采用 逆向思维更容易判断
    - 类中的代码行数、函数或者属性过多
    - 类依赖的其他类过多，或者依赖类的其他类过多
    - 私有方法过多
    - 比较难给类起一个合适的名字
    - 类中大量的方法都是集中操作类中的某几个属性
- 类的职责是否设计得越单一越好？
  - 单一职责原则是为了实现代码高内聚、低耦合。
  - 如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

## 开闭原则 Open Closed Principle / OCP

- 定义：
  - 代码是指： 软件实体（模块、类、方法等）
  - 对扩展开放、对修改关闭
  - 添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。
  - 理解
    - 并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发
    - 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。
- 如何做到“对扩展开放、修改关闭”？
  - 要时刻具备扩展意识、抽象意识、封装意识
  - 如何设计代码结构，事先留好扩展点，以便将新的代码灵活地插入到扩展点上

## 里式替换原则 Liskov Substitution Principle / LSP

- 定义：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
- 理解：
  - 解决：继承关系中子类该如何设计
  - design by contract，父类定义了函数的“协议”
  - 子类可以改变函数的内部实现逻辑，但不能改变函数原有的“协议”
  - 协议包括
    - 函数声明要实现的功能
    - 对输入、输出、异常 约定
    - 注释中所罗列的任何特殊说明

  - 里式替换原则跟多态的区别？
    - 多态
      - 面向对象编程的一大特性
      - 面向对象编程语言的一种语法
      - 一种代码实现的思路
    - LSP
      - 一种设计原则
      - 指导继承关系中子类该如何设计

## 接口隔离原则 Interface Segregation Principle / ISP

- 定义：
  - 客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。
  - 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数
- 接口隔离原则与单一职责原则的区别？
  - 单一职责
    - 针对的是模块、类、接口的设计
  - 接口隔离原则
    - 更侧重于接口的设计
    - 提供了一种判断接口的职责是否单一的标准
      - 通过调用者如何使用接口来间接地判定
      - 如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一

## 依赖反转原则  Dependency Inversion Principle / DIP

- 定义：
  - 高层模块不要依赖低层模块
  - 高层模块和低层模块应该通过抽象来互相依赖
  - 抽象不要依赖具体实现细节
  - 具体实现细节依赖抽象。
  - 调用链上，调用者属于高层，被调用者属于低层。
- 控制反转（IOC）
  - 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计
  - “控制”指的是对程序执行流程的控制
  - 而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。
  - 流程的控制权从程序员“反转”到了框架。
- 依赖注入（DI）
  - 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用

## KISS 原则 Keep It Simple and Stupid

- 尽量保持简单
  - “简单”并不是以代码行数来考量的
  - 逻辑复杂度
  - 实现难度
  - 代码的可读性
  - 本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则
- 如何实现KISS?
  - 不要使用同事可能不懂的技术来实现代码；
  - 不要重复造轮子，要善于使用已经有的工具类库；
  - 不要过度优化

## DRY 原则 Don’t Repeat Yourself

### 不要重复造轮子

- 违反行为
  - 代码执行重复
  - 逻辑不重复，但功能语义重复的代码
- 不违反
  - 逻辑重复，但功能语义不重复的代码

### 提高代码可复用性的一些方法

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。
在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

相比于代码的可复用性，DRY 原则适用性更强一些。
我们可以不写可复用的代码，但一定不能写重复的代码。

- 方法
  - 减少代码耦合
  - 满足单一职责原则
  - 模块化
  - 业务/与非业务逻辑分离
  - 通用代码下沉
  - 继承/多态/抽象/封装
  - 应用模板等 设计模式

## 迪米特法则 Law of Demeter / LOD  

最小知识原则 The Least Knowledge Principle）

- 定义：每个模块只应该了解那些与它关系密切的模块的有限知识。
- 理解：
  - 希望减少类之间的耦合
  - 不该有直接依赖关系的类之间，不要有依赖
  - 有依赖关系的类之间，尽量只依赖必要的接口
  - 每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

### 如何理解“高内聚、松耦合”？

- 高内聚
  - 指相近的功能应该放到同一个类中
    - 相近的功能往往会被同时修改，放到同一个类中，修改会比较集中
  - 不相近的功能不要放到同一类中
    - 不相近的功放到一起，容易增加理解成本，也容易被忽略

- 松耦合
  - 类与类之间的依赖关系 **简单/清晰**。
  - 即使两个类有依赖关系，一个类的代码改动也 **不会或者很少** 导致 依赖类的代码改动。

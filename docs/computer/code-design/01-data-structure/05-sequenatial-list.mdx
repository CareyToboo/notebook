# 线性表-顺序存储

线性表的使用[顺序存储](/notebook/docs/computer/code-design/data-structure/data-basic#顺序存储结构)实现又叫<t c1>顺序表</t>。

## 参考资料链接

- [C语言 指针基础](http://c.biancheng.net/c/80/)
- [5分钟看懂什么是 malloc](https://zhuanlan.zhihu.com/p/105090421)
- [C语言 malloc函数与指针](https://zhuanlan.zhihu.com/p/197918331)
- [C语言 完整实现顺序表 0201_SqList/main.c](https://60f2cac42d-share.lightly.teamcode.com)

## 注意点

- 数据元素<t bg1>逻辑相邻物理存储也相邻</t>，使用<t c2>元素在列表中的下标</t>表示逻辑相邻关系。
![5-1](./images/5-1.png)
- 顺序表<t c2>初始化时需要申请一块完整的地址空间</t>，用于存放数据元素。
  - 由于空间是提前申请的，因此所存放的<t c2>元素数量是固定的</t>。
  - 当插入元素时，需要<t c2>注意内存空间溢出的问题</t>。（当插入前，发现即将溢出，可重新申请地址空间，然后再插入数据）
- 由于每一个数据元素使用的空间是固定的。如果已知某一个位置数据元素的首地址与数据元素的占用空间大小，能够计算出，列表中其他元素的地址。

```txt
  已知：

    单个数据元素占用空间：   c = sizeof(ElementType)
    顺序表首元素内存首地址为：LOC(a1)
  
  求：第i个元素，ai的内存首地址是多少？

    LOC(ai) = LOC(a1) + (i-1) * c
```

![5-2](./images/5-2.png)

## [线性表ADT](/notebook/docs/computer/code-design/data-structure/linear-list#线性表抽象数据类型adt)使用C语言实现

公用宏定义

```c
#define TRUE        1   // 真/是
#define FALSE       0   // 假/否
#define OK          1   // 通过/成功
#define ERROR       0   // 错误/失败

//系统中已有此状态码定义，要防止冲突
#ifndef OVERFLOW
#define OVERFLOW    -2  //堆栈上溢
#endif

//系统中已有此状态码定义，要防止冲突
#ifndef NULL
#define NULL ((void*)0)
#endif

/* 状态码类型 */
typedef int Status;
```

### 顺序表定义

```c
#define LIST_INIT_SIZE 100  // 顺序表存储空间的初始分配量
#define LIST_INCREMENT  10  // 顺序表存储空间的分配增量

/* 顺序表元素类型定义 */
typedef int ElemType;

/*
 * 顺序表结构
 *
 * 注：elem在使用前需要先为其分配内存，且元素从elem[0]处开始存储
 */
typedef struct {
    ElemType* elem;     // 顺序表存储空间的基址（指向顺序表所占内存的起始位置）
    int length;   // 当前顺序表长度（包含多少元素）
    int listsize; // 当前分配的存储容量（可以存储多少元素）
} SqList;
```

### 初始化空顺序表

- 需要理解 `malloc()` 函数分配内存空间的使用。注意处理分配失败的情况。
- 注意给 `SqList` 结构体设置`length`,`listsize`初始值。

```c
/**
 * 操作结果: 构造一个空的线性表L
 */
Status InitList(SqList *L) {
  // malloc 分配指定容量的内存，如果分配失败 返回 NULL
  (*L).elem = (ElemType*) malloc(LIST_INIT_SIZE * sizeof(ElemType));

  if ((*L).elem === NULL) {
    // 如果分配失败 直接退出，并返回对应错误码
    exit(OVERFLOW);
  }

  (*L).length = 0; // 设置默认长度
  (*L).listsize = LIST_INIT_SIZE; // 设置列表最大长度

  return OK;
}
```

### 销毁顺序表

- 需要理解 `free()` 函数释放内存空间的使用。
- 注意重置 顺序表的 `length`,`listsize` 数据

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 销毁线性表L
 */
Status DestroyList(&L) {
  // 下列情况会导致L不存在
  //  1. 当未初始化线性表，直接调用 DestroyList 时
  //  2. 重复调用 DestroyList 时

  // 确保线性表L已经存在。
  if (L == NULL || (*L).elem == NULL) {
    return ERROR;
  }

  // 释放 顺序表 内存空间
  free((*L).elem);

  // 重置 顺序表 结构体数据
  (*L).elem = NULL;
  (*L).length = 0;
  (*L).listsize = 0;

  return OK;
}
```

### 清空顺序表

- 要注意<t b l l2>清空</t>与<t b l l2>销毁</t>的区别
  - 清空: 只是<t l l2>将顺序表的长度设为0</t>，该顺序表任然可以继续使用。在表中继续添加元素时，会覆盖原有值。
  - 销毁: 释放顺序表内存空间，不再使用。

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 将L重置为空表。
 */
Status ClearList(&L) {
  // 确认 顺序表存在
  if (L == NULL && (*L).elem == NULL) {
    return ERROR;
  }
  // 置为空表
  (*L).length = 0;
  
  return OK;
}
```

### 判断顺序表是否为空

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 若L为空表，则返回TRUE，否则返回FALSE
 */
Status ListEmpty(L) {
  // 确认 L 存在
  if (L.elem == NULL) {
    return ERROR;
  }
  // 长度 为 0，表示 空表
  if (L.length == 0) {
    return TRUE;
  }
  // 不为空表
  return FALSE;
}
```

### 获取元素长度

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 返回L中数据元素个数。
 */
int ListLength(L) {
  // 确认 L 存在
  if (L.elem == NULL) {
    return ERROR
  }
  return L.length;
}
```

### 获取某位置元素的值

- 注意： <t l l2>参数 i 定义是<t c2>位置</t></t>。 所以i的取值区间为 $1 <= i <= L.length$

```c
/**
 * 初始条件: 线性表L已存在，l <= i <= ListLength(L) 操作结果; 用e返回L中第i个数据元素的值。
 */
Status GetElem(L, i, ElementType* e) {
  // 确认 i 的值有效
  if (i < 1 || i > L.length) {
    return ERROR;
  }
  // 确认 L 存在
  if (L.elem == NULL) {
    return ERROR;
  }
  // 修改 指针 e 的值
  *e = L.elem[i-1];

  return OK;
}
```

### 获取某元素的位置

```c
/**
 * 初始条件: 线性表L已存在，compare()是数据元素判定函数。
 * 操作结果: 返回L中第1个与e满足关系 compare() 的数据元素的位序。若这样的数据元素不存在，则返回值为0。
 */
```

### 获取某元素前驱元素

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 若 cur.e 是L的数据元素，且不是第一个，则用 pre.e 返回它的前驱，否则操作失败，pre.e 无定义。
 */ 
```

### 获取某元素后继元素

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 若 cur.e 是L的数据元素，且不是最后一个，则用 next.e 返回它的后继，否则操作失败，next.e 无定义。
 */
```

### 某位置插入元素

```c
/**
 * 初始条件: 线性表L已存在，1 < i < ListLength(L) + 1
 * 操作结果: 在L中第i个位置之前插人新的数据元素eL的长度加1
 */
```

### 删除某位置元素

```c
/**
 * 初始条件:线性表L已存在且非空，1 < i < ListLength(L)
 * 操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1
 */
```

### 遍历顺序表

```c
/**
 * 初始条件: 线性表L已存在。
 * 操作结果: 依次对L的每个数据元素调用函数 visit()。一旦 visit() 失败，则操作失败。
 */
```

## 顺序表实际使用
